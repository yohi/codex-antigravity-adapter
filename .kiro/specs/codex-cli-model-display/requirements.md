# 要件定義書

## プロジェクト概要（入力）
codex-cli のモデル選択メニュー（/model）を改修し、Antigravity Adapter などの外部プロバイダーから動的にモデル一覧を取得・表示する機能を実装する。

### 詳細要件ドラフト（EARS形式）

以下の要件定義は **EARS (Easy Approach to Requirements Syntax)** に基づいています。

#### 機能要件

* **When** モデル選択メニューがアクセスされる（`/model`）, システムは 設定済みのモデルプロバイダー（例: Antigravity Adapter `http://localhost:3000/v1/models`）から利用可能なモデルを取得すること。
* **システムは** 取得した動的モデルと既存の静的プリセットを統合すること。
* **If** モデルプロバイダーが到達不能またはエラーを返す, システムは サイレントに失敗し、それらのモデルをリストから除外してクラッシュしないこと。
* **システムは** プロバイダーが返したすべてのモデル（例: `gemini-3-*`, `claude-*`）を選択メニューに表示すること。

#### 技術制約

* システムは **Rust** を使用して実装されること（既存の `codex-rs` コードベースを拡張）。
* システムは 既存のHTTPクライアント依存関係（例: `reqwest` または `ureq`）を再利用し、新しい依存関係を最小限に抑えること。
* すべての実行は **Devcontainer** 環境内で行われること。
* ホスト側での実行は厳密に **禁止** されること。

## 要件

### 要件1: 外部プロバイダーからの動的モデル取得
**目的:** CLIユーザーとして、/model を開いたときに外部プロバイダーからモデル一覧を取得できるようにしたい。そうすることで、最新の提供モデルを選択できる。

#### 受入基準
1. **When** `/model` メニューが開かれる場合、システムは 設定済みの外部プロバイダーエンドポイント（例: `http://localhost:3000/v1/models`）からモデル一覧を取得すること。
2. **When** 複数の外部プロバイダーが設定されている場合、システムは 各プロバイダーのモデル一覧を取得して統合対象にすること。

#### 設定ファイル仕様

##### 1. サポートされる設定ファイル形式
システムは以下の形式の設定ファイルをサポートすること：
- **YAML形式**: `~/.config/codex/providers.yaml` または `./codex-providers.yaml`
- **JSON形式**: `~/.config/codex/providers.json` または `./codex-providers.json`

##### 2. 設定スキーマと例

**プロバイダーエントリのスキーマ**:
```yaml
providers:
  - name: string           # プロバイダー名（必須、一意）
    endpoint: string       # エンドポイントURL（必須、http/https）
    auth:                  # 認証情報（オプション）
      type: string         # 認証タイプ: "bearer", "api_key", "none"（デフォルト: "none"）
      token: string        # Bearerトークン（type=bearerの場合）
      api_key: string      # APIキー（type=api_keyの場合）
      header: string       # APIキーヘッダー名（type=api_keyの場合、デフォルト: "X-API-Key"）
    timeout: integer       # タイムアウト秒数（オプション、デフォルト: 3）
    enabled: boolean       # 有効/無効フラグ（オプション、デフォルト: true）
```

**YAML設定例**:
```yaml
providers:
  - name: "Antigravity Adapter"
    endpoint: "http://localhost:3000/v1/models"
    enabled: true

  - name: "Production Gateway"
    endpoint: "https://api.example.com/v1/models"
    auth:
      type: "bearer"
      token: "${MODEL_GATEWAY_TOKEN}"  # 環境変数参照
    timeout: 5
    enabled: true

  - name: "Backup Provider"
    endpoint: "https://backup.example.com/models"
    auth:
      type: "api_key"
      api_key: "${BACKUP_API_KEY}"
      header: "X-Custom-API-Key"
    enabled: false
```

**JSON設定例**:
```json
{
  "providers": [
    {
      "name": "Antigravity Adapter",
      "endpoint": "http://localhost:3000/v1/models",
      "enabled": true
    },
    {
      "name": "Production Gateway",
      "endpoint": "https://api.example.com/v1/models",
      "auth": {
        "type": "bearer",
        "token": "${MODEL_GATEWAY_TOKEN}"
      },
      "timeout": 5,
      "enabled": true
    }
  ]
}
```

##### 3. デフォルト動作（設定ファイルが存在しない場合）
**When** 設定ファイルが存在しない、または空である場合、システムは以下の動作を行うこと：

1. **ビルトインデフォルトプロバイダーを使用**:
   - `http://localhost:3000/v1/models`（Antigravity Adapter）を自動的に試行する。
   - 到達不能の場合、警告メッセージを表示せず、静的プリセットのみを表示する。

2. **ユーザー通知**（オプション、初回実行時のみ）:
   ```text
   [INFO] 外部プロバイダー設定が見つかりません。デフォルトで localhost:3000 を試行します。
   [INFO] カスタム設定を追加するには: ~/.config/codex/providers.yaml を作成してください。
   ```

3. **no-op動作**（代替オプション）:
   - 設定ファイルが明示的に空の場合、外部プロバイダーへの問い合わせをスキップする。
   - 静的プリセットのみを表示し、サイレントに動作する。

##### 4. 検証ルールとエラーハンドリング

**設定ファイル読み込み時の検証**:

| 検証項目 | 検証ルール | エラー時の動作 |
|---------|----------|--------------|
| **ファイル形式** | YAML/JSONとして正しくパース可能か | エラーメッセージ表示 + 終了コード1 + デフォルトプロバイダーへフォールバック |
| **providersフィールド** | 配列型であること | エラーメッセージ表示 + 終了コード1 + デフォルトプロバイダーへフォールバック |
| **name（必須）** | 文字列、1文字以上、プロバイダー間で一意 | 警告メッセージ + そのプロバイダーをスキップ |
| **endpoint（必須）** | 有効なURL（http/https）、ホスト名が解決可能 | 警告メッセージ + そのプロバイダーをスキップ |
| **auth.type** | "bearer", "api_key", "none"のいずれか | 警告メッセージ + auth部分を無視 |
| **auth.token/api_key** | 指定されたtypeに応じて必須フィールドが存在 | 警告メッセージ + そのプロバイダーをスキップ |
| **timeout** | 正の整数（1〜30秒） | 警告メッセージ + デフォルト値（3秒）を使用 |
| **enabled** | 真偽値 | 警告メッセージ + デフォルト値（true）を使用 |

**エラーメッセージと終了コードの仕様**:

1. **設定ファイル形式エラー**（終了コード: 1）:
   ```text
   [ERROR] 設定ファイルの読み込みに失敗しました: ~/.config/codex/providers.yaml
   [ERROR] 詳細: YAML parse error at line 5: invalid indentation
   [INFO] デフォルトプロバイダー（localhost:3000）へフォールバックします。
   ```

2. **必須フィールド欠落**（警告、終了コードは0）:
   ```text
   [WARN] プロバイダー設定エラー（インデックス: 1）: 'endpoint' フィールドが必須です。
   [WARN] このプロバイダーをスキップします。
   ```

3. **URL検証エラー**（警告、終了コードは0）:
   ```text
   [WARN] プロバイダー 'Production Gateway': 無効なエンドポイントURL: 'htp://invalid'
   [WARN] このプロバイダーをスキップします。
   ```

4. **認証エラー**（実行時、警告、終了コードは0）:
   ```text
   [WARN] プロバイダー 'Production Gateway': 認証に失敗しました (HTTP 401)
   [WARN] このプロバイダーのモデルを除外します。
   ```

5. **重複プロバイダー名**（警告、終了コードは0）:
   ```text
   [WARN] プロバイダー名 'Antigravity Adapter' が重複しています（インデックス: 2）。
   [WARN] 最初の定義のみを使用し、重複をスキップします。
   ```

**環境変数参照の処理**:
- `${VAR_NAME}` 形式の環境変数参照をサポートすること。
- 環境変数が未定義の場合、警告を表示し、そのプロバイダーをスキップすること。
  ```text
  [WARN] プロバイダー 'Production Gateway': 環境変数 'MODEL_GATEWAY_TOKEN' が未定義です。
  [WARN] このプロバイダーをスキップします。
  ```

### 要件2: モデル一覧の統合と表示
**目的:** CLIユーザーとして、動的モデルと静的プリセットが統合されて表示されるようにしたい。そうすることで、一つの一覧で候補を確認できる。

#### 受入基準

##### 1. 決定論的な表示順序
**When** モデル一覧を表示する場合、システムは以下の順序で表示すること：

1. **静的プリセット優先**:
   - 静的プリセット（組み込みモデル）を常に最初に表示する。
   - 静的プリセット内では、名前のアルファベット順（昇順）でソートする。

2. **動的モデルのソート**:
   - 動的モデルは、プロバイダー名のアルファベット順でグループ化する。
   - 同一プロバイダー内では、モデル名のアルファベット順（昇順）でソートする。

3. **表示例**:
   ```text
   [静的プリセット]
   1. claude-3-opus
   2. gpt-4

   [Antigravity Adapter]
   3. gemini-2.0-flash-exp
   4. gemini-3.0-ultra-preview

   [Production Gateway]
   5. claude-sonnet-4-20250514
   6. gpt-4o-2024-11-20
   ```

4. **ユーザー設定可能なソートキー**（オプション機能）:
   - 設定ファイルで `display.sort_key` を指定可能にすること。
   - サポートされるソートキー:
     - `name`: モデル名のアルファベット順（デフォルト）
     - `provider`: プロバイダー名優先、その後モデル名
     - `recent`: 最近使用したモデルを優先（使用履歴が必要）
   - 設定例:
     ```yaml
     display:
       sort_key: "name"  # "name" | "provider" | "recent"
       static_first: true  # 静的プリセットを優先するかどうか
     ```

##### 2. 重複解決ルール
**When** 静的プリセットと動的モデルで同じモデル名が存在する場合、システムは以下のルールで処理すること：

1. **名前の正規化**:
   - モデル名の比較前に、以下の正規化を実施する:
     - 大文字小文字を区別しない比較（ケース非依存）
     - 先頭・末尾の空白を削除
     - 連続する空白を1つに圧縮
   - 例: `"GPT-4 "` と `"gpt-4"` は同一と見なす。

2. **重複解決戦略**（設定可能）:
   - **戦略A: 静的優先（デフォルト）**:
     - 静的プリセットが存在する場合、動的モデルは除外する。
     - 表示例: `claude-3-opus (static)` のみ表示。

   - **戦略B: プロバイダータグ付き並列表示**:
     - 静的と動的の両方を表示し、プロバイダータグで区別する。
     - 表示例:
       ```text
       1. claude-3-opus [static]
       2. claude-3-opus [Antigravity Adapter]
       3. claude-3-opus [Production Gateway]
       ```

3. **設定例**:
   ```yaml
   display:
     duplicate_resolution: "static_first"  # "static_first" | "tagged_all"
   ```

4. **重複ログ**:
   - 重複が検出された場合、デバッグログに記録すること。
   ```text
   [DEBUG] 重複モデル検出: 'claude-3-opus' (static, Antigravity Adapter)
   [DEBUG] 解決戦略 'static_first' を適用: 動的モデルを除外
   ```

##### 3. プログレッシブ vs 全取得待機の動作
**When** 複数のプロバイダーからモデルを取得する場合、システムは以下の動作モードをサポートすること：

1. **デフォルト: 全取得待機モード（wait-for-all）**:
   - すべてのプロバイダーからの応答（またはタイムアウト）を待機してから一覧を表示する。
   - タイムアウト: 最大5秒（設定可能）。
   - タイムアウト後、取得済みのモデルのみを表示する。

2. **オプション: インクリメンタル表示モード（progressive）**:
   - プロバイダーから応答が返るたびに、一覧を逐次更新する。
   - 部分結果の明確なマーカーを表示する。
   - 設定例:
     ```yaml
     display:
       progressive_mode: true  # false（デフォルト）またはtrue
       progressive_timeout: 10  # 秒単位
     ```

3. **部分結果マーカー**:
   - インクリメンタルモードの場合、以下のバナーを表示する:
     ```text
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     ⚠️  部分結果を表示中（2/3 プロバイダー応答済み）
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     ```

4. **タイムアウト処理**:
   - 設定されたタイムアウト後も応答がないプロバイダーは除外する。
   - 最終的な状態を明示する:
     ```text
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     ✓ すべての利用可能なプロバイダーから取得完了
       (2/3 成功、1 タイムアウト)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     ```

##### 4. 取得中のユーザーフィードバック
**While** 外部プロバイダーからモデルを取得している間、システムは以下のフィードバックを提供すること：

1. **スピナー/進捗表示**:
   - 取得中はスピナーアニメーションを表示する。
   - 例:
     ```text
     ⠋ モデル一覧を取得中... (Antigravity Adapter)
     ```
   - 複数プロバイダーの場合、進捗を表示する:
     ```text
     ⠙ モデル一覧を取得中... [2/3 プロバイダー]
     ```

2. **ローディングバナー**:
   - 取得開始時に一時的なバナーを表示する:
     ```text
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     🔄 外部プロバイダーからモデルを取得中...
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     ```

3. **状態遷移**:
   システムは以下の状態を明確に遷移し、ユーザーに通知すること：

   | 状態 | 表示 | 説明 |
   |------|------|------|
   | **loading** | `⠋ モデル一覧を取得中...` | 初期状態、プロバイダーへリクエスト中 |
   | **partial** | `⚠️ 部分結果を表示中（2/3）` | 一部のプロバイダーから応答済み（progressiveモードのみ） |
   | **complete** | `✓ 取得完了（3/3 成功）` | すべてのプロバイダーから応答済み |
   | **error** | `⚠️ 一部のプロバイダーで取得失敗（1/3 失敗）` | 一部または全てのプロバイダーでエラー |

4. **エラー時の表示**:
   - エラーが発生した場合、取得成功したモデルと静的プリセットを表示する。
   - エラーの概要を通知する:
     ```text
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     ⚠️ 一部のプロバイダーで取得失敗
       - Production Gateway: タイムアウト
       - Backup Provider: 認証エラー (401)

     静的プリセットと利用可能なモデルを表示します。
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     ```

##### 5. 大規模結果の処理
**When** モデル一覧が大量（例: 100以上）の場合、システムは以下のメカニズムをサポートすること：

1. **ページネーション/仮想化リスト**:
   - デフォルトで最初の50モデルを表示する。
   - ハードリミット: 初回表示は最大50件。
   - 表示例:
     ```text
     [モデル 1-50 / 234]

     1. claude-3-opus [static]
     2. gpt-4 [static]
     ...
     50. model-name-50 [Antigravity Adapter]

     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     さらに 184 モデルがあります
     [Enter] 次の50件を表示 | [S] 検索 | [Q] 戻る
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     ```

2. **"show more"コントロール**:
   - ユーザーが[Enter]を押すと、次の50件を追加表示する。
   - [S]キーで検索モードに入る。
   - [Q]キーでメニューを閉じる。

3. **クライアント側フィルタリング/検索**:
   - リアルタイム検索機能を提供する。
   - 検索モード表示例:
     ```text
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     🔍 検索: gpt▊
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

     [検索結果: 12件]
     1. gpt-4 [static]
     2. gpt-4-turbo [static]
     3. gpt-4o-2024-11-20 [Production Gateway]
     ...
     ```

4. **モデル名の正規化ルール**（プロバイダー間の統一）:
   - プロバイダー固有のプレフィックス/サフィックスを標準化する。
   - 正規化ルール:
     - プロバイダープレフィックスを削除: `provider:model-name` → `model-name`
     - バージョン番号を統一: `model-v1.0` → `model-1.0`
     - 大文字小文字を統一: 表示時は元の大文字小文字を保持、内部処理では小文字化

5. **大規模データのメモリ管理**:
   - 仮想化リストを使用し、表示されていないモデルをメモリから解放する。
   - メモリ使用量が10MBを超える場合、古いエントリを破棄する（LRU方式）。

6. **設定可能なハードリミット**:
   ```yaml
   display:
     page_size: 50  # 1ページあたりの表示件数
     hard_limit: 500  # 取得する最大モデル数
   ```

#### 統合された受入基準のまとめ
1. **When** モデル一覧を表示する場合、システムは 決定論的な順序（静的優先、プロバイダー名→モデル名のソート）で表示すること。
2. **When** 重複するモデル名が存在する場合、システムは 設定された重複解決戦略（静的優先またはタグ付き並列表示）を適用すること。
3. **When** 複数のプロバイダーからモデルを取得する場合、システムは 全取得待機モードまたはインクリメンタル表示モードで動作すること。
4. **While** モデルを取得している間、システムは スピナー、進捗表示、状態遷移を通じてユーザーにフィードバックを提供すること。
5. **When** モデル一覧が大量（100以上）の場合、システムは ページネーション、検索機能、ハードリミットを適用して処理すること。

### 要件3: 堅牢なエラーハンドリング
**目的:** CLIユーザーとして、外部プロバイダー障害時も /model が安全に動作してほしい。そうすることで、操作中にツールがクラッシュしたり応答不能になったりしない。

#### 受入基準

##### 1. ログ/メトリクスポリシー（サイレント失敗時）
**When** 外部プロバイダーでエラーが発生する場合、システムは以下のログとメトリクスを記録すること：

**ログレベルの使い分け**:

| ログレベル | 記録対象 | 例 |
|-----------|---------|-----|
| **DEBUG** | 正常なリクエスト/レスポンス、キャッシュヒット/ミス | `[DEBUG] プロバイダー 'Antigravity Adapter': リクエスト成功 (234ms)` |
| **INFO** | 設定読み込み、プロバイダー検出、取得完了 | `[INFO] 3つのプロバイダーを検出しました` |
| **WARN** | 一時的なエラー、タイムアウト、4xx/5xxエラー | `[WARN] プロバイダー 'Production Gateway': タイムアウト (3000ms)` |
| **ERROR** | 設定エラー、予期しない例外、全プロバイダー失敗 | `[ERROR] すべてのプロバイダーで取得失敗。静的プリセットのみを表示します。` |

**具体的なログ出力例**:

1. **DEBUG レベル**:
   ```text
   [DEBUG] プロバイダー 'Antigravity Adapter': リクエスト開始
   [DEBUG] プロバイダー 'Antigravity Adapter': 応答受信 (234ms, 12モデル)
   [DEBUG] キャッシュヒット: 'Production Gateway' (TTL残り: 180s)
   [DEBUG] 重複モデル除外: 'gpt-4' (static優先)
   ```

2. **INFO レベル**:
   ```text
   [INFO] 設定ファイル読み込み: ~/.config/codex/providers.yaml
   [INFO] 3つのプロバイダーを検出: Antigravity Adapter, Production Gateway, Backup Provider
   [INFO] モデル取得完了: 静的プリセット 8件、動的モデル 24件
   ```

3. **WARN レベル**:
   ```text
   [WARN] プロバイダー 'Production Gateway': タイムアウト (3000ms)
   [WARN] プロバイダー 'Backup Provider': HTTP 503 Service Unavailable
   [WARN] 部分取得完了: 1/3 プロバイダー成功
   ```

4. **ERROR レベル**:
   ```text
   [ERROR] すべてのプロバイダーで取得失敗
   [ERROR] 詳細:
     - Antigravity Adapter: 接続拒否
     - Production Gateway: タイムアウト
     - Backup Provider: HTTP 401 Unauthorized
   [ERROR] 静的プリセットのみを表示します
   ```

**メトリクスの記録**（オプション、監視システム統合用）:

以下のメトリクスを記録し、監視システムへの送信をサポートすること（例: Prometheus形式）：

| メトリクス名 | 型 | 説明 | ラベル |
|------------|----|----|-------|
| `codex_provider_requests_total` | Counter | プロバイダーへのリクエスト総数 | `provider`, `status` (success/failure) |
| `codex_provider_request_duration_ms` | Histogram | リクエスト時間（ミリ秒） | `provider`, `status` |
| `codex_provider_models_fetched_total` | Counter | 取得したモデル数 | `provider` |
| `codex_provider_errors_total` | Counter | エラー発生回数 | `provider`, `error_type` (timeout/4xx/5xx/connection) |
| `codex_cache_hits_total` | Counter | キャッシュヒット回数 | `provider` |
| `codex_cache_misses_total` | Counter | キャッシュミス回数 | `provider` |

**メトリクス出力例**（Prometheus形式）:
```prometheus
codex_provider_requests_total{provider="Antigravity Adapter",status="success"} 42
codex_provider_requests_total{provider="Production Gateway",status="failure"} 5
codex_provider_request_duration_ms{provider="Antigravity Adapter",status="success"} 234
codex_provider_errors_total{provider="Production Gateway",error_type="timeout"} 3
```

##### 2. 部分失敗時の表示ルール
**When** 一部のプロバイダーが成功し、一部が失敗する場合、システムは以下のルールで表示すること：

1. **成功したプロバイダーのモデルのみ表示**:
   - プロバイダーAが成功、プロバイダーBが失敗した場合、Aのモデルのみを一覧に含める。
   - 静的プリセットは常に表示する。

2. **部分取得状態の明示**:
   - ヘッダーまたはフッターに部分取得であることを示すバナーを表示する。
   - 表示例:
     ```text
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     ⚠️  部分的な結果を表示中
       成功: 1/3 プロバイダー (Antigravity Adapter)
       失敗: 2/3 プロバイダー (Production Gateway: タイムアウト、Backup Provider: HTTP 503)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     ```

3. **失敗詳細の簡潔な通知**:
   - 失敗したプロバイダー名とエラー理由を簡潔に表示する。
   - 詳細はログファイルを参照するよう案内する。
   ```text
   [INFO] 詳細なエラー情報はログファイルを確認してください: ~/.local/state/codex/logs/provider-errors.log
   ```

4. **操作継続性**:
   - 部分失敗でもユーザーは通常通りモデルを選択できる。
   - UIがブロックされたり、異常終了したりしないこと。

##### 3. キャッシング動作
**When** プロバイダーへのリクエストが失敗する場合、システムはキャッシュを活用すること：

1. **最終成功結果の使用（Last-Successful Results）**:
   - プロバイダーが失敗した場合、最後に成功した結果をキャッシュから取得する。
   - キャッシュが有効期限内（TTL以内）であれば、そのまま使用する。

2. **TTL（Time-To-Live）設定**:
   - キャッシュの有効期限: デフォルト5分（300秒）。
   - 設定ファイルで調整可能にすること。
   - 設定例:
     ```yaml
     cache:
       ttl: 300  # 秒単位（0 = キャッシュ無効）
       stale_while_revalidate: 600  # 秒単位
     ```

3. **Stale-While-Revalidate ポリシー**:
   - キャッシュが期限切れでも、バックグラウンドで再取得を試みる間は古いキャッシュを使用する。
   - stale_while_revalidate期間: TTL後さらに10分間（600秒）。
   - 動作:
     1. TTL期限切れ → 古いキャッシュを即座に返す。
     2. バックグラウンドで非同期に再取得を開始。
     3. 再取得成功 → 新しいデータでキャッシュ更新。
     4. 再取得失敗 → 古いキャッシュを保持。

4. **キャッシュ利用時の表示**:
   - キャッシュから取得した場合、ユーザーに通知する（オプション）。
   - 表示例:
     ```text
     [INFO] プロバイダー 'Production Gateway' のモデルは最後の成功結果（2分前）を使用しています
     ```

5. **キャッシュ無効化**:
   - ユーザーが明示的にキャッシュをバイパスできるオプションを提供する。
   - 例: `--no-cache` フラグ。

##### 4. 全動的取得失敗時のUX
**When** すべての外部プロバイダーでモデル取得が失敗する場合、システムは以下のUXを提供すること：

1. **静的プリセットのみ表示**:
   - 静的プリセット（組み込みモデル）のみを一覧に表示する。
   - 動的モデルセクションは非表示にする。

2. **控えめなバナー/ラベル表示**:
   - 動的モデルが利用不可であることを控えめに通知する。
   - 表示例:
     ```text
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     [静的プリセット]
     1. claude-3-opus
     2. gpt-4
     3. gpt-4-turbo

     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     ℹ️  外部プロバイダーからのモデルは現在利用できません
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     ```

3. **エラー原因の簡潔な説明**（オプション）:
   - ユーザーが詳細を確認できるよう、簡潔なエラー原因を表示する。
   - 表示例:
     ```text
     ℹ️  外部プロバイダーからのモデルは現在利用できません
       理由: すべてのプロバイダーで接続エラー
       詳細: ~/.local/state/codex/logs/provider-errors.log
     ```

4. **操作継続性**:
   - 静的プリセットを選択して通常通り動作を継続できること。
   - エラーメッセージが煩わしくならないよう、控えめに表示すること。

##### 5. エラー分類とハンドリングの違い
**When** プロバイダーからエラーが返される場合、システムは以下の分類とハンドリングを実施すること：

**エラー分類とハンドリング戦略**:

| エラータイプ | HTTPステータス | 説明 | ハンドリング戦略 |
|------------|--------------|------|----------------|
| **タイムアウト** | N/A | リクエストが3秒以内に完了しない | リトライ（最大2回） |
| **接続拒否** | N/A | プロバイダーが到達不能（Connection Refused） | リトライ（最大2回） |
| **DNS解決失敗** | N/A | ホスト名が解決できない | スキップ（リトライなし） |
| **4xx クライアントエラー** | 400-499 | リクエストに問題がある | スキップ（リトライなし） |
| **401 Unauthorized** | 401 | 認証エラー | スキップ（リトライなし）、設定確認を促す |
| **403 Forbidden** | 403 | アクセス権限なし | スキップ（リトライなし） |
| **404 Not Found** | 404 | エンドポイントが存在しない | スキップ（リトライなし）、設定確認を促す |
| **429 Too Many Requests** | 429 | レート制限超過 | リトライ（バックオフあり、最大2回） |
| **5xx サーバーエラー** | 500-599 | サーバー側の一時的な問題 | リトライ（最大2回） |
| **502/503/504** | 502-504 | サーバー過負荷/メンテナンス | リトライ（最大2回） |

**ハンドリング戦略の詳細**:

1. **リトライ対象**:
   - タイムアウト、接続拒否、429、5xxエラー。
   - 最大2回までリトライ。

2. **スキップ対象**:
   - DNS解決失敗、4xxエラー（401, 403, 404など）。
   - リトライせず、そのプロバイダーを除外する。

3. **特別なエラーメッセージ**:
   - **401/403**: `[WARN] 認証エラーが発生しました。設定ファイルのauth情報を確認してください。`
   - **404**: `[WARN] エンドポイントが見つかりません。設定ファイルのendpoint URLを確認してください。`
   - **429**: `[WARN] レート制限に達しました。しばらく待ってから再試行します。`

##### 6. リトライ/バックオフ戦略
**When** リトライ可能なエラーが発生する場合、システムは以下の戦略でリトライすること：

**リトライパラメータ**:

| パラメータ | 値 | 説明 |
|-----------|-----|------|
| **最大試行回数** | 3回（初回 + リトライ2回） | 合計3回までリクエストを試行 |
| **初期遅延** | 500ms | 最初のリトライまでの待ち時間 |
| **バックオフ乗数** | 2.0 | 遅延時間の増加率（エクスポネンシャルバックオフ） |
| **ジッター** | ±20% | 遅延時間にランダムなばらつきを追加 |
| **最大遅延** | 5000ms（5秒） | 遅延時間の上限 |

**リトライスケジュール例**:

1. **初回リクエスト**: 失敗 → リトライ決定
2. **1回目のリトライ**: 500ms + ジッター（±100ms） = 400〜600ms 待機
3. **2回目のリトライ**: 1000ms + ジッター（±200ms） = 800〜1200ms 待機
4. **3回目以降**: リトライしない → プロバイダーを除外

**ジッターの計算式**:
```text
実際の遅延 = 基本遅延 × (1 + ランダム(-0.2, +0.2))
```

**リトライ時のログ例**:
```text
[DEBUG] プロバイダー 'Production Gateway': リクエスト失敗（タイムアウト）
[DEBUG] 1回目のリトライを実行（500ms後）...
[DEBUG] プロバイダー 'Production Gateway': リクエスト失敗（タイムアウト）
[DEBUG] 2回目のリトライを実行（1000ms後）...
[DEBUG] プロバイダー 'Production Gateway': リクエスト失敗（タイムアウト）
[WARN] プロバイダー 'Production Gateway': 最大試行回数に達しました。このプロバイダーを除外します。
```

**429エラーのRetry-After対応**:
- HTTPレスポンスヘッダー `Retry-After` が存在する場合、その値を優先する。
- `Retry-After` の値が最大遅延（5秒）を超える場合、そのプロバイダーをスキップする。

**設定可能なリトライパラメータ**（オプション）:
```yaml
retry:
  max_attempts: 3  # 最大試行回数（1〜5）
  initial_delay_ms: 500  # 初期遅延（ミリ秒）
  backoff_multiplier: 2.0  # バックオフ乗数（1.5〜3.0）
  jitter_factor: 0.2  # ジッター率（0.0〜0.5）
  max_delay_ms: 5000  # 最大遅延（ミリ秒）
```

#### 統合された受入基準のまとめ
1. **When** エラーが発生する場合、システムは 適切なログレベル（DEBUG/INFO/WARN/ERROR）で記録し、オプションでメトリクスを送信すること。
2. **When** 一部のプロバイダーが失敗する場合、システムは 成功したプロバイダーのモデルのみを表示し、部分取得状態を明示すること。
3. **When** プロバイダーが失敗する場合、システムは キャッシュ（TTL、stale-while-revalidate）を活用して最終成功結果を提供すること。
4. **When** すべてのプロバイダーが失敗する場合、システムは 静的プリセットのみを表示し、控えめなバナーで通知すること。
5. **When** エラーが発生する場合、システムは エラータイプに応じた適切なハンドリング（リトライ vs スキップ）を実施すること。
6. **When** リトライ可能なエラーが発生する場合、システムは エクスポネンシャルバックオフ戦略（最大3回、初期500ms、乗数2.0、ジッター±20%）でリトライすること。

## パフォーマンス要件

### 要件4: レスポンスタイムとリソース制限
**目的:** システムのパフォーマンスを保証し、ユーザー体験を損なわない応答性を提供する。

#### 具体的な閾値
1. **最大取得レイテンシ**:
   - 単一プロバイダーへのHTTPリクエストは最大3秒以内に完了すること（タイムアウト設定）。
   - タイムアウト後はそのプロバイダーをスキップし、他のプロバイダーまたは静的プリセットで継続すること。

2. **UI応答期待値**:
   - `/model` メニューの初回表示は5秒以内に開始されること（静的プリセット表示 + 動的モデル取得の並行処理）。
   - 動的モデルの取得中もUIがブロックされず、プログレス表示または静的プリセットの先行表示を行うこと。

3. **メモリ制限**:
   - 動的モデルリストのメモリ使用量は最大10MB以内に抑えること（通常想定: 数百モデル × 数KB/モデル）。
   - キャッシュを使用する場合、キャッシュサイズの上限を設定し、メモリリークを防止すること。

#### 実装上の注意
- 並行リクエストを使用する場合、同時接続数を制限すること（例: 最大5並行）。
- タイムアウト値は設定ファイルで調整可能にすることが望ましい。

## セキュリティ考慮事項

### 要件5: 安全なプロバイダー接続
**目的:** 外部プロバイダーへの接続を安全に行い、セキュリティリスクを最小化する。

#### 具体的な対策
1. **プロバイダーURL検証**:
   - 設定ファイルに記載されたプロバイダーURLは起動時にスキーマとホスト名を検証すること（http/https、有効なドメイン/IPアドレス）。
   - 無効なURLが検出された場合、警告をログに記録し、そのプロバイダーをスキップすること。

2. **許可ドメイン（ホワイトリスト）**:
   - 外部プロバイダーの許可ドメインリストを設定可能にすること（例: `localhost`, `127.0.0.1`, `*.example.com`）。
   - デフォルトではlocalhostのみ許可し、本番環境では明示的な設定を要求すること。

3. **URLインジェクション軽減**:
   - プロバイダーURLのパス部分やクエリパラメータに対して、インジェクション攻撃を防止するためのサニタイゼーションを実施すること。
   - URLパースライブラリ（例: `url` crate）を使用し、手動での文字列結合を避けること。

4. **レート制限**:
   - 同一プロバイダーへのリクエスト頻度を制限すること（例: 10秒に1回まで）。
   - キャッシュを活用し、短時間での重複リクエストを防止すること。

5. **HTTPS推奨**:
   - 本番環境ではHTTPSの使用を推奨し、HTTPを使用する場合は警告を表示すること。

#### 実装上の注意
- TLS証明書の検証を有効にすること（`reqwest`のデフォルト動作を維持）。
- 機密情報（APIキー等）が必要な場合、環境変数または安全な設定ファイルから読み込むこと。

## テスト戦略

### 要件6: 包括的なテストカバレッジ
**目的:** システムの信頼性を保証し、エッジケースやエラー状況を適切に処理できることを検証する。

#### テストシナリオ
1. **エラーレスポンスのモック**:
   - 外部プロバイダーが404、500、503などのHTTPエラーを返す場合のテストケースを作成すること。
   - モックサーバー（例: `mockito` crate）を使用して、各エラー状況をシミュレートすること。

2. **タイムアウト/遅延シミュレーション**:
   - プロバイダーが3秒以上応答しない場合のタイムアウト処理をテストすること。
   - モックサーバーで意図的に遅延を発生させ、システムが適切にタイムアウトすることを確認すること。

3. **テストプロバイダーリスト**:
   - 複数のプロバイダー（成功、失敗、タイムアウト）を混在させたテストケースを作成すること。
   - 一部のプロバイダーが失敗しても、他のプロバイダーと静的プリセットが正常に表示されることを確認すること。

4. **キャッシュ動作の検証**:
   - キャッシュが有効な場合、2回目のリクエストがキャッシュから返されることを確認すること。
   - キャッシュの有効期限切れ後、新しいリクエストが発行されることを確認すること。

#### テスト環境
- ユニットテスト: 各モジュール（HTTP取得、統合ロジック、エラーハンドリング）を個別にテストすること。
- 統合テスト: モックサーバーを使用して、エンドツーエンドの動作を検証すること。
- Devcontainer環境でのテスト実行を標準とすること。

## 実装ガイダンス

### 要件7: 実装の推奨アプローチ
**目的:** 保守性が高く、拡張可能な実装を提供するための指針を示す。

#### 推奨実装パターン
1. **async/awaitの使用**:
   - Rustの非同期ランタイム（例: `tokio`）を使用し、async/awaitパターンで実装すること。
   - 複数のプロバイダーへのリクエストを並行処理し、全体の待ち時間を短縮すること。

2. **並行リクエストと制限**:
   - `tokio::spawn` または `futures::future::join_all` を使用して、複数のプロバイダーへ並行リクエストを発行すること。
   - 同時接続数を制限するため、セマフォ（例: `tokio::sync::Semaphore`）を使用すること。
   - デフォルトの並行数: 最大5並行（設定可能にすることが望ましい）。

3. **リクエストタイムアウト**:
   - `reqwest::Client::timeout` を使用して、各HTTPリクエストに3秒のタイムアウトを設定すること。
   - タイムアウト発生時は、そのプロバイダーをスキップし、エラーログを記録すること。

4. **リトライとバックオフ**:
   - 一時的なネットワークエラー（タイムアウト、接続失敗）に対して、最大2回のリトライを実施すること。
   - リトライ間隔: 初回500ms、2回目1秒（エクスポネンシャルバックオフ）。
   - HTTPエラー（4xx、5xx）に対するリトライは実施しないこと（サーバー側の問題のため）。

5. **キャッシングとメモリ管理**:
   - 動的モデルリストを一定期間（例: 5分）キャッシュし、重複リクエストを削減すること。
   - キャッシュは`std::sync::Arc<Mutex<HashMap>>`等を使用してスレッドセーフに実装すること。
   - メモリ上限（10MB）を超える場合、古いエントリから破棄すること（LRU方式を推奨）。

#### モジュール設計の推奨事項
- **プロバイダークライアント**: 外部プロバイダーへのHTTPリクエストを抽象化したモジュール。
- **モデル統合ロジック**: 動的モデルと静的プリセットを統合するロジック。
- **エラーハンドリング**: カスタムエラー型を定義し、各エラー状況を明確に分類すること。
- **設定管理**: プロバイダーURL、タイムアウト、並行数などの設定を外部ファイル（例: TOML）から読み込むこと。

## 成功指標

### 要件8: システムの成功を測定する指標
**目的:** 実装の効果を定量的に評価し、継続的な改善を可能にする。

#### 主要指標（KPI）
1. **復旧時間（MTTR: Mean Time To Recovery）**:
   - 外部プロバイダー障害発生時、システムが静的プリセットで動作を継続するまでの時間。
   - 目標: 障害検出から3秒以内にフォールバック完了。

2. **キャッシュヒット率**:
   - キャッシュから動的モデルを返す割合。
   - 目標: 同一セッション内での2回目以降のアクセスで80%以上のキャッシュヒット率。

3. **リクエスト成功率**:
   - 外部プロバイダーへのリクエストが成功する割合。
   - 目標: 正常な環境で95%以上の成功率（リトライ含む）。

4. **平均応答時間**:
   - `/model` メニュー表示までの平均時間。
   - 目標: 正常な環境で2秒以内（並行処理とキャッシュを活用）。

5. **エラーハンドリングカバレッジ**:
   - エラーケース（タイムアウト、HTTPエラー、ネットワーク障害）のテストカバレッジ。
   - 目標: すべてのエラーケースで100%のテストカバレッジ。

#### モニタリングとログ
- プロバイダーへのリクエスト結果（成功/失敗/タイムアウト）をログに記録すること。
- キャッシュヒット/ミスの統計を記録し、分析可能にすること。
- エラー発生時には、エラーの種類、プロバイダーURL、タイムスタンプをログに記録すること。
