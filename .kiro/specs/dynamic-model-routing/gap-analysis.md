# ギャップ分析: 動的モデルルーティング (Dynamic Model Routing)

## 1. 分析サマリー
本機能は、クライアントからのリクエストに含まれるモデルエイリアス（例: `@fast`）を解釈し、適切なモデルIDへ動的にルーティングする機能です。
現行のコードベースは Hono を使用したプロキシサーバーであり、リクエストボディをパースした後、直ちに変換処理を行っています。
現状、エイリアス定義の読み込み機能や、リクエスト内容（モデル名、メッセージ本文）を動的に書き換えるミドルウェア的な介入ポイントが存在しません。
したがって、エイリアス設定管理サービスの追加と、リクエスト処理パイプラインへのルーティングロジックの注入が必要です。

## 2. 現状のコードベース (Current State)
*   **ルーティング処理 (`src/proxy/proxy-router.ts`):**
    *   `/v1/chat/completions` エンドポイントで `c.req.json()` を呼び出し、リクエストボディを取得。
    *   取得したボディを `ChatCompletionRequestSchema` で検証。
    *   検証後のデータを `transformService.handleCompletion` に渡して処理。
*   **設定管理 (`src/config/model-settings-service.ts`):**
    *   固定リスト、環境変数、カスタムJSONファイルからモデル定義を読み込んでいる。
    *   エイリアス定義（`alias` -> `modelId` のマッピング）を扱う機能は存在しない。
*   **リクエスト変換 (`src/transformer/request.ts`):**
    *   OpenAI形式からAntigravity形式への変換を担当。
    *   ここでリクエスト内容を変更することは可能だが、責務としては「変換」であり「ルーティング（宛先決定）」ではない。

## 3. ギャップの特定 (Gap Identification)

| ID | 要件 | 現状 | ギャップ |
| :--- | :--- | :--- | :--- |
| G-1 | `model-aliases.json` からのエイリアス読み込み | 機能なし | エイリアス定義をロード・保持する新しいサービスまたは既存サービスの拡張が必要。 |
| G-2 | リクエスト内のエイリアスタグ検出 (`@fast` 等) | 機能なし | リクエストボディ（`messages`）を検査するロジックが必要。 |
| G-3 | ターゲットモデルへの ID 書き換え | 固定的な処理のみ | 検出したエイリアスに基づき `model` フィールドを書き換えるロジックが必要。 |
| G-4 | メッセージ本文からのエイリアスタグ除去 | そのまま通過 | `messages` 配列の先頭要素を編集するロジックが必要。 |
| G-5 | パススルー動作（エイリアスなしの場合） | 現状がパススルー | 既存の動作を維持しつつ、条件付きで介入する必要がある。 |

## 4. 実装オプション (Implementation Options)

### オプション A: 専用サービスとルーター内統合 (推奨)
*   **概要:** `ModelAliasService` を新設し、エイリアスのロードと解決ロジックを集約する。`proxy-router.ts` 内で JSON パース直後にこのサービスを呼び出してペイロードを加工する。
*   **メリット:**
    *   責務が明確（エイリアス管理はサービス、適用はルーター）。
    *   Hono のミドルウェア機構と格闘せず、パース済みのオブジェクトを安全に操作できる。
    *   既存の `ModelSettingsService` と似た構成で統一感が取れる。
*   **デメリット:**
    *   `proxy-router.ts` にロジックが追加される（ただし、呼び出しのみで薄く保てる）。

### オプション B: Hono ミドルウェアとしての実装
*   **概要:** `createMiddleware` で独立したミドルウェアを作成し、`app.use(...)` で適用する。
*   **メリット:**
    *   ルーターのコードを汚さない。
*   **デメリット:**
    *   リクエストボディの再パース問題。`c.req.json()` は一度しか読めないため、ミドルウェアで読むとハンドラーで読めなくなる等の考慮が必要（バリデータ前段での介入が複雑になりがち）。

### オプション C: TransformService への統合
*   **概要:** `transformRequestBasics` 内でエイリアス処理を行う。
*   **メリット:**
    *   変更箇所が少ない。
*   **デメリット:**
    *   `TransformService` は「プロトコル変換」が責務であり、ルーティング（どのモデルを使うか）の決定を行うのは責務違反。ログ出力等の観点からも、変換前に行うべき。

## 5. リスクと技術的負債 (Risks & Tech Debt)
*   **リスク:** ユーザーメッセージの編集（エイリアス除去）において、意図せず必要なテキストまで消してしまうリスク。
    *   *対策:* 要件にある「直後が空白または終端」という条件を厳密に実装し、ユニットテストで境界値を網羅する。
*   **技術的負債:** `model-aliases.json` の監視（ホットリロード）は今回の要件には含まれないが、将来的に再起動なしでの変更反映が欲しくなる可能性がある。現在は起動時読み込みのみとする。

## 6. 推奨事項 (Recommendation)
**オプション A** を採用する。
具体的には以下の手順を推奨する：

1.  `src/config/alias-config-service.ts` (仮) を作成し、`model-aliases.json` の読み込みと解決ロジック（`resolveAlias(modelId, messages) -> { modelId, messages }`）を実装する。
2.  `src/main.ts` でこのサービスを初期化する。
3.  `src/proxy/proxy-router.ts` にサービスを注入し、`c.req.json()` の直後に適用する。

## 次のステップ
*   設計フェーズ (`/kiro:spec-design dynamic-model-routing`) に進み、`AliasConfigService` の詳細設計を行う。
